// Generated by CoffeeScript 1.8.0
var Computer;

Computer = (function() {
  function Computer() {}

  Computer.prototype.move = function(grid, snake, snack) {
    return this.findPath(grid, snake, snack);
  };

  Computer.prototype.findPath = function(grid, start, goal) {
    var a, current, fringe, node, path, priority, _i, _j, _len, _len1, _ref, _ref1;
    console.log(start);
    fringe = PriorityQueue();
    _ref = this.neighbours(grid, start, goal, 0, new Array());
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      a = _ref[_i];
      fringe.push(a.priority, a.value1, a.value2);
    }
    while (fringe.size() > 0) {
      node = fringe.pop();
      priority = node.priority;
      current = node.value1;
      path = node.value2;
      console.log(priority, current, path);
      if (current.row === goal.row && current.column === goal.column) {
        return this.direction(start, path[0]);
      }
      _ref1 = this.neighbours(grid, current, goal, priority, path);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        a = _ref1[_j];
        fringe.push(a.priority, a.value1, a.value2);
      }
    }
  };

  Computer.prototype.neighbours = function(grid, cell, goal, priority, path) {
    var d, neighbour, neighbours, newPath, p, pos, _i, _len, _ref;
    neighbours = [];
    _ref = [
      {
        x: 0,
        y: -1
      }, {
        x: 1,
        y: 0
      }, {
        x: 0,
        y: 1
      }, {
        x: -1,
        y: 0
      }
    ];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pos = _ref[_i];
      neighbour = {
        row: cell.row - pos.y,
        column: cell.column - pos.x
      };
      if (neighbour.row >= 0 && neighbour.row <= grid[0].length - 1) {
        if (neighbour.column >= 0 && neighbour.column <= grid.length - 1) {
          p = this.deepCopy(path);
          d = this.distance(neighbour, goal);
          p.push(grid[neighbour.row][neighbour.column]);
          newPath = this.deepCopy(p);
          neighbours.push({
            priority: priority + d,
            value1: grid[neighbour.row][neighbour.column],
            value2: newPath
          });
        }
      }
    }
    return neighbours;
  };

  Computer.prototype.distance = function(a, b) {
    var d, deltaX, deltaY;
    deltaX = a.column - b.column;
    deltaY = a.row - b.row;
    d = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    return d;
  };

  Computer.prototype.direction = function(from, to) {
    return {
      x: from.column - to.column,
      y: from.row - to.row
    };
  };

  Computer.prototype.deepCopy = function(a) {
    var b, e, f, _i, _len;
    b = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      e = a[_i];
      f = {
        row: e.row,
        column: e.column,
        isSnake: e.isSnake,
        isSnack: e.isSnack
      };
      b.push(f);
    }
    return b;
  };

  return Computer;

})();

window.Computer = Computer;
